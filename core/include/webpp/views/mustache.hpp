/*
 * Created by moisrex on 11/04/22.
 * Initial source from: https://github.com/kainjow/Mustache.git
 *
 * Boost Software License - Version 1.0
 *
 * Mustache
 * Copyright 2015-2020 Kevin Wojniak
 * Copyright 2022      Mohammad Bahoosh
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef WEBPP_MUSTACHE_HPP
#define WEBPP_MUSTACHE_HPP


#include "../strings/trim.hpp"
#include "../traits/enable_traits.hpp"
#include "html.hpp"

#include <array>


namespace webpp::views {

    template <typename string_type>
    class basic_renderer {
      public:
        using type1 = stl::function<string_type(const string_type&)>;
        using type2 = stl::function<string_type(const string_type&, bool escaped)>;

        string_type operator()(const string_type& text) const {
            return type1_(text);
        }

        string_type operator()(const string_type& text, bool escaped) const {
            return type2_(text, escaped);
        }

      private:
        basic_renderer(const type1& t1, const type2& t2) : type1_(t1), type2_(t2) {}

        const type1& type1_;
        const type2& type2_;

        template <typename StringType>
        friend class mustache;
    };

    template <typename string_type>
    class basic_lambda_t {
      public:
        using type1 = stl::function<string_type(const string_type&)>;
        using type2 =
          stl::function<string_type(const string_type&, const basic_renderer<string_type>& render)>;

        basic_lambda_t(const type1& t) : type1_(new type1(t)) {}
        basic_lambda_t(const type2& t) : type2_(new type2(t)) {}

        [[nodiscard]] bool is_type1() const {
            return static_cast<bool>(type1_);
        }
        [[nodiscard]] bool is_type2() const {
            return static_cast<bool>(type2_);
        }

        [[nodiscard]] const type1& type1_value() const {
            return *type1_;
        }
        [[nodiscard]] const type2& type2_value() const {
            return *type2_;
        }

        // Copying
        basic_lambda_t(const basic_lambda_t& l) {
            if (l.type1_) {
                type1_.reset(new type1(*l.type1_));
            } else if (l.type2_) {
                type2_.reset(new type2(*l.type2_));
            }
        }

        string_type operator()(const string_type& text) const {
            return (*type1_)(text);
        }

        string_type operator()(const string_type& text, const basic_renderer<string_type>& render) const {
            return (*type2_)(text, render);
        }

      private:
        stl::unique_ptr<type1> type1_;
        stl::unique_ptr<type2> type2_;
    };

    template <typename string_type>
    class basic_data;
    template <typename string_type>
    using basic_object = stl::unordered_map<string_type, basic_data<traits_type>>;
    template <typename string_type>
    using basic_list = stl::vector<basic_data<traits_type>>;
    template <typename string_type>
    using basic_partial = stl::function<string_type()>;
    template <typename string_type>
    using basic_lambda = typename basic_lambda_t<string_type>::type1;
    template <typename string_type>
    using basic_lambda2 = typename basic_lambda_t<string_type>::type2;

    template <typename string_type>
    class basic_data {
      public:
        enum class type {
            object,
            string,
            list,
            bool_true,
            bool_false,
            partial,
            lambda,
            lambda2,
            invalid,
        };

        // Construction
        basic_data() : basic_data(type::object) {}
        basic_data(const string_type& string) : type_{type::string} {
            str_.reset(new string_type(string));
        }
        basic_data(const typename string_type::value_type* string) : type_{type::string} {
            str_.reset(new string_type(string));
        }
        basic_data(const basic_object<string_type>& obj) : type_{type::object} {
            obj_.reset(new basic_object<string_type>(obj));
        }
        basic_data(const basic_list<string_type>& l) : type_{type::list} {
            list_.reset(new basic_list<string_type>(l));
        }
        basic_data(type t) : type_{t} {
            switch (type_) {
                case type::object: obj_.reset(new basic_object<string_type>); break;
                case type::string: str_.reset(new string_type); break;
                case type::list: list_.reset(new basic_list<string_type>); break;
                default: break;
            }
        }
        basic_data(const string_type& name, const basic_data& var) : basic_data{} {
            set(name, var);
        }
        basic_data(const basic_partial<string_type>& p) : type_{type::partial} {
            partial_.reset(new basic_partial<string_type>(p));
        }
        basic_data(const basic_lambda<string_type>& l) : type_{type::lambda} {
            lambda_.reset(new basic_lambda_t<string_type>(l));
        }
        basic_data(const basic_lambda2<string_type>& l) : type_{type::lambda2} {
            lambda_.reset(new basic_lambda_t<string_type>(l));
        }
        basic_data(const basic_lambda_t<string_type>& l) {
            if (l.is_type1()) {
                type_ = type::lambda;
            } else if (l.is_type2()) {
                type_ = type::lambda2;
            }
            lambda_.reset(new basic_lambda_t<string_type>(l));
        }
        basic_data(bool b) : type_{b ? type::bool_true : type::bool_false} {}

        // Copying
        basic_data(const basic_data& dat) : type_(dat.type_) {
            if (dat.obj_) {
                obj_.reset(new basic_object<string_type>(*dat.obj_));
            } else if (dat.str_) {
                str_.reset(new string_type(*dat.str_));
            } else if (dat.list_) {
                list_.reset(new basic_list<string_type>(*dat.list_));
            } else if (dat.partial_) {
                partial_.reset(new basic_partial<string_type>(*dat.partial_));
            } else if (dat.lambda_) {
                lambda_.reset(new basic_lambda_t<string_type>(*dat.lambda_));
            }
        }

        // Move
        basic_data(basic_data&& dat) : type_{dat.type_} {
            if (dat.obj_) {
                obj_ = stl::move(dat.obj_);
            } else if (dat.str_) {
                str_ = stl::move(dat.str_);
            } else if (dat.list_) {
                list_ = stl::move(dat.list_);
            } else if (dat.partial_) {
                partial_ = stl::move(dat.partial_);
            } else if (dat.lambda_) {
                lambda_ = stl::move(dat.lambda_);
            }
            dat.type_ = type::invalid;
        }
        basic_data& operator=(basic_data&& dat) {
            if (this != &dat) {
                obj_.reset();
                str_.reset();
                list_.reset();
                partial_.reset();
                lambda_.reset();
                if (dat.obj_) {
                    obj_ = stl::move(dat.obj_);
                } else if (dat.str_) {
                    str_ = stl::move(dat.str_);
                } else if (dat.list_) {
                    list_ = stl::move(dat.list_);
                } else if (dat.partial_) {
                    partial_ = stl::move(dat.partial_);
                } else if (dat.lambda_) {
                    lambda_ = stl::move(dat.lambda_);
                }
                type_     = dat.type_;
                dat.type_ = type::invalid;
            }
            return *this;
        }

        // Type info
        [[nodiscard]] bool is_object() const {
            return type_ == type::object;
        }
        [[nodiscard]] bool is_string() const {
            return type_ == type::string;
        }
        [[nodiscard]] bool is_list() const {
            return type_ == type::list;
        }
        [[nodiscard]] bool is_bool() const {
            return is_true() || is_false();
        }
        [[nodiscard]] bool is_true() const {
            return type_ == type::bool_true;
        }
        [[nodiscard]] bool is_false() const {
            return type_ == type::bool_false;
        }
        [[nodiscard]] bool is_partial() const {
            return type_ == type::partial;
        }
        [[nodiscard]] bool is_lambda() const {
            return type_ == type::lambda;
        }
        [[nodiscard]] bool is_lambda2() const {
            return type_ == type::lambda2;
        }
        [[nodiscard]] bool is_invalid() const {
            return type_ == type::invalid;
        }

        // Object data
        [[nodiscard]] bool is_empty_object() const {
            return is_object() && obj_->empty();
        }
        [[nodiscard]] bool is_non_empty_object() const {
            return is_object() && !obj_->empty();
        }
        void set(const string_type& name, const basic_data& var) {
            if (is_object()) {
                auto it = obj_->find(name);
                if (it != obj_->end()) {
                    obj_->erase(it);
                }
                obj_->insert(stl::pair<string_type, basic_data>{name, var});
            }
        }
        const basic_data* get(const string_type& name) const {
            if (!is_object()) {
                return nullptr;
            }
            const auto& it = obj_->find(name);
            if (it == obj_->end()) {
                return nullptr;
            }
            return &it->second;
        }

        // List data
        void push_back(const basic_data& var) {
            if (is_list()) {
                list_->push_back(var);
            }
        }
        const basic_list<string_type>& list_value() const {
            return *list_;
        }
        [[nodiscard]] bool is_empty_list() const {
            return is_list() && list_->empty();
        }
        [[nodiscard]] bool is_non_empty_list() const {
            return is_list() && !list_->empty();
        }
        basic_data& operator<<(const basic_data& data) {
            push_back(data);
            return *this;
        }

        // String data
        const string_type& string_value() const {
            return *str_;
        }

        basic_data& operator[](const string_type& key) {
            return (*obj_)[key];
        }

        const basic_partial<string_type>& partial_value() const {
            return (*partial_);
        }

        const basic_lambda<string_type>& lambda_value() const {
            return lambda_->type1_value();
        }

        const basic_lambda2<string_type>& lambda2_value() const {
            return lambda_->type2_value();
        }

      private:
        type                                         type_;
        stl::unique_ptr<basic_object<string_type>>   obj_;
        stl::unique_ptr<string_type>                 str_;
        stl::unique_ptr<basic_list<string_type>>     list_;
        stl::unique_ptr<basic_partial<string_type>>  partial_;
        stl::unique_ptr<basic_lambda_t<string_type>> lambda_;
    };

    template <typename string_type>
    class delimiter_set {
      public:
        string_type begin;
        string_type end;
        delimiter_set() : begin(default_begin), end(default_end) {}
        [[nodiscard]] bool is_default() const {
            return begin == default_begin && end == default_end;
        }
        static const string_type default_begin;
        static const string_type default_end;
    };

    template <typename string_type>
    const string_type delimiter_set<string_type>::default_begin(2, '{');
    template <typename string_type>
    const string_type delimiter_set<string_type>::default_end(2, '}');

    template <Traits TraitsType>
    struct basic_context {
        using traits_type = TraitsType;

        virtual ~basic_context()                               = default;
        virtual void push(const basic_data<traits_type>* data) = 0;
        virtual void pop()                                     = 0;

        virtual const basic_data<traits_type>* get(const string_type& name) const         = 0;
        virtual const basic_data<traits_type>* get_partial(const string_type& name) const = 0;
    };

    template <Traits TraitsType>
    struct context : public basic_context<TraitsType> {
        using traits_type = TraitsType;

        context(const basic_data<traits_type>* data) {
            push(data);
        }

        context() = default;

        void push(const basic_data<traits_type>* data) override {
            items_.insert(items_.begin(), data);
        }

        void pop() override {
            items_.erase(items_.begin());
        }

        const basic_data<traits_type>* get(const string_type& name) const override {
            // process {{.}} name
            if (name.size() == 1 && name.at(0) == '.') {
                return items_.front();
            }
            if (name.find('.') == string_type::npos) {
                // process normal name without having to split which is slower
                for (const auto& item : items_) {
                    const auto var = item->get(name);
                    if (var) {
                        return var;
                    }
                }
                return nullptr;
            }
            // process x.y-like name
            const auto names = split(name, '.');
            for (const auto& item : items_) {
                auto var = item;
                for (const auto& n : names) {
                    var = var->get(n);
                    if (!var) {
                        break;
                    }
                }
                if (var) {
                    return var;
                }
            }
            return nullptr;
        }

        const basic_data<traits_type>* get_partial(const string_type& name) const override {
            for (const auto& item : items_) {
                const auto var = item->get(name);
                if (var) {
                    return var;
                }
            }
            return nullptr;
        }

        context(const context&)            = delete;
        context& operator=(const context&) = delete;

      private:
        stl::vector<const basic_data<traits_type>*> items_;
    };

    template <Traits TraitsType>
    struct line_buffer_state {
        using traits_type = TraitsType;
        using string_type = traits::general_string<traits_type>;

        string_type data;
        bool        contained_section_tag = false;

        [[nodiscard]] constexpr bool is_empty_or_contains_only_whitespace() const noexcept {
            for (const auto ch : data) {
                // don't look at newlines
                if (ch != ' ' && ch != '\t') {
                    return false;
                }
            }
            return true;
        }

        constexpr void clear() {
            data.clear();
            contained_section_tag = false;
        }
    };

    template <Traits TraitsType>
    struct context_internal {
        using traits_type = TraitsType;

        basic_context<traits_type>&    ctx;
        delimiter_set<traits_type>     delim_set;
        line_buffer_state<traits_type> line_buffer;

        constexpr context_internal(basic_context<string_type>& a_ctx) : ctx(a_ctx) {}
    };

    enum class tag_type {
        text,
        variable,
        unescaped_variable,
        section_begin,
        section_end,
        section_begin_inverted,
        comment,
        partial,
        set_delimiter,
    };

    template <typename string_type>
    class mstch_tag /* gcc doesn't allow "tag tag;" so rename the class :( */ {
      public:
        string_type                                 name;
        tag_type                                    type = tag_type::text;
        stl::shared_ptr<string_type>                section_text;
        stl::shared_ptr<delimiter_set<string_type>> delim_set;
        [[nodiscard]] bool                          is_section_begin() const {
                                     return type == tag_type::section_begin || type == tag_type::section_begin_inverted;
        }
        [[nodiscard]] bool is_section_end() const {
            return type == tag_type::section_end;
        }
    };

    template <Traits TraitsType>
    struct context_pusher {
        using traits_type = TraitsType;
        context_pusher(context_internal<traits_type>& ctx, const basic_data<traits_type>* data) : ctx_(ctx) {
            ctx.ctx.push(data);
        }
        ~context_pusher() {
            ctx_.ctx.pop();
        }
        context_pusher(const context_pusher&)            = delete;
        context_pusher& operator=(const context_pusher&) = delete;

      private:
        context_internal<traits_type>& ctx_;
    };

    template <Traits TraitsType>
    struct component {
        using traits_type      = TraitsType;
        using string_type      = traits::general_string<traits_type>;
        using string_view_type = traits::string_view<traits_type>;
        using string_size_type = typename string_view_type::size_type;

        using children_type = traits::generalify_allocators<traits_type, stl::vector<component>>;

        string_view_type       text;
        mstch_tag<string_type> tag;
        children_type          children;
        string_size_type       position = string_view_type::npos;

        enum class walk_control {
            walk, // "continue" is reserved :/
            stop,
            skip,
        };


        template <EnabledTraits ET>
        constexpr component(ET const&        et,
                            string_view_type t = "",
                            string_size_type p = string_view_type::npos)
          : text(t),
            children{et.allocs_pack.template general_allocator<component>()},
            position(p) {}

        [[nodiscard]] constexpr bool is_text() const noexcept {
            return tag.type == tag_type::text;
        }

        [[nodiscard]] constexpr bool is_newline() const noexcept {
            return is_text() && ((text.size() == 2 && text[0] == '\r' && text[1] == '\n') ||
                                 (text.size() == 1 && (text[0] == '\n' || text[0] == '\r')));
        }

        [[nodiscard]] constexpr bool is_non_newline_whitespace() const noexcept {
            return is_text() && !is_newline() && text.size() == 1 && (text[0] == ' ' || text[0] == '\t');
        }

        template <typename WalkCallback>
        constexpr void walk_children(WalkCallback& callback) {
            for (auto& child : children) {
                if (child.walk(callback) != walk_control::walk) {
                    break;
                }
            }
        }

      private:
        template <typename WalkCallback>
        constexpr walk_control walk(WalkCallback&& callback) {
            walk_control control{callback(*this)};
            if (control == walk_control::stop) {
                return control;
            } else if (control == walk_control::skip) {
                return walk_control::walk;
            }
            for (auto& child : children) {
                control = child.walk(callback);
                if (control == walk_control::stop) {
                    return control;
                }
            }
            return control;
        }
    };


    template <Traits TraitsType>
    struct mustache : enable_traits<TraitsType> {
        using traits_type      = TraitsType;
        using string_type      = traits::general_string<traits_type>;
        using string_view_type = traits::string_view<traits_type>;

        using string_size_type  = typename string_type::size_type;
        using escape_handler    = stl::function<string_type(string_view_type)>;
        using component_type    = component<traits_type>;
        using walk_control_type = typename component_type::walk_control;

      private:
        string_type    error_message_;
        component_type root_component_;
        escape_handler escape_;

      public:
        constexpr mustache(string_view_type input) : mustache() {
            context<string_type>          ctx;
            context_internal<string_type> context{ctx};
            parser(input, context);
        }

        [[nodiscard]] constexpr bool is_valid() const noexcept {
            return error_message_.empty();
        }

        [[nodiscard]] constexpr string_view_type error_message() const noexcept {
            return error_message_;
        }

        constexpr void set_custom_escape(const escape_handler& escape_fn) {
            escape_ = escape_fn;
        }

        template <typename stream_type>
        constexpr stream_type& render(const basic_data<traits_type>& data, stream_type& stream) {
            render(data, [&stream](string_view_type str) {
                stream << str;
            });
            return stream;
        }

        constexpr string_type render(const basic_data<traits_type>& data) {
            stl::basic_ostringstream<typename string_type::value_type> ss;
            return render(data, ss).str();
        }

        template <typename stream_type>
        constexpr stream_type& render(basic_context<string_type>& ctx, stream_type& stream) {
            context_internal<string_type> context{ctx};
            render(
              [&stream](string_view_type str) {
                  stream << str;
              },
              context);
            return stream;
        }

        constexpr string_type render(basic_context<string_type>& ctx) {
            stl::basic_ostringstream<typename string_type::value_type> ss;
            return render(ctx, ss).str();
        }

        using render_handler = stl::function<void(string_view_type)>;
        constexpr void render(const basic_data<traits_type>& data, const render_handler& handler) {
            if (!is_valid()) {
                return;
            }
            context<string_type>          ctx{&data};
            context_internal<string_type> context{ctx};
            render(handler, context);
        }

        constexpr mustache() : escape_(html_escape<string_type>) {}

      private:
        constexpr mustache(string_view_type input, context_internal<string_type>& ctx) : mustache() {
            parser(input, ctx);
        }



        /////// Parser


        void parse(string_view_type input, context_internal<string_type>& ctx) const {
            using streamstring = stl::basic_ostringstream<typename string_type::value_type>;

            const string_view_type brace_delimiter_end_unescaped("}}}");
            const string_size_type input_size{input.size()};

            bool current_delimiter_is_brace{ctx.delim_set.is_default()};

            stl::vector<component_type*>  sections{&root_component_};
            stl::vector<string_size_type> section_starts;
            string_type                   current_text;
            string_size_type              current_text_position = string_type::npos;

            current_text.reserve(input_size);

            const auto process_current_text = [&current_text, &current_text_position, &sections]() {
                if (!current_text.empty()) {
                    const component_type comp{current_text, current_text_position};
                    sections.back()->children.push_back(comp);
                    current_text.clear();
                    current_text_position = string_type::npos;
                }
            };

            constexpr static stl::array<string_view_type, 5> whitespace{{"\r\n", "\n", "\r", " ", "\t"}};

            for (string_size_type input_position = 0; input_position != input_size;) {
                bool parse_tag = false;

                if (input.compare(input_position, ctx.delim_set.begin.size(), ctx.delim_set.begin) == 0) {
                    process_current_text();

                    // Tag start delimiter
                    parse_tag = true;
                } else {
                    bool parsed_whitespace = false;
                    for (const auto& whitespace_text : whitespace) {
                        if (input.compare(input_position, whitespace_text.size(), whitespace_text) == 0) {
                            process_current_text();

                            const component_type comp{whitespace_text, input_position};
                            sections.back()->children.push_back(comp);
                            input_position += whitespace_text.size();

                            parsed_whitespace = true;
                            break;
                        }
                    }

                    if (!parsed_whitespace) {
                        if (current_text.empty()) {
                            current_text_position = input_position;
                        }
                        current_text.append(1, input[input_position]);
                        input_position++;
                    }
                }

                if (!parse_tag) {
                    continue;
                }

                // Find the next tag start delimiter
                const string_size_type tag_location_start = input_position;

                // Find the next tag end delimiter
                string_size_type       tag_contents_location{tag_location_start + ctx.delim_set.begin.size()};
                const bool             tag_is_unescaped_var{current_delimiter_is_brace &&
                                                tag_location_start != (input_size - 2) &&
                                                input.at(tag_contents_location) == ctx.delim_set.begin.at(0)};
                const string_view_type current_tag_delimiter_end{
                  tag_is_unescaped_var ? brace_delimiter_end_unescaped : ctx.delim_set.end};
                const auto current_tag_delimiter_end_size = current_tag_delimiter_end.size();
                if (tag_is_unescaped_var) {
                    ++tag_contents_location;
                }
                const string_size_type tag_location_end{
                  input.find(current_tag_delimiter_end, tag_contents_location)};
                if (tag_location_end == string_view_type::npos) {
                    streamstring ss;
                    ss << "Unclosed tag at " << tag_location_start;
                    error_message_.assign(ss.str());
                    return;
                }

                // Parse tag
                const auto tag_contents = ascii::trim_copy(
                  string_view_type{input, tag_contents_location, tag_location_end - tag_contents_location});
                component_type comp;
                if (!tag_contents.empty() && tag_contents[0] == '=') {
                    if (!parse_set_delimiter_tag(tag_contents, ctx.delim_set)) {
                        streamstring ss;
                        ss << "Invalid set delimiter tag at " << tag_location_start;
                        error_message_.assign(ss.str());
                        return;
                    }
                    current_delimiter_is_brace = ctx.delim_set.is_default();
                    comp.tag.type              = tag_type::set_delimiter;
                    comp.tag.delim_set.reset(new delimiter_set<string_type>(ctx.delim_set));
                }
                if (comp.tag.type != tag_type::set_delimiter) {
                    parse_tag_contents(tag_is_unescaped_var, tag_contents, comp.tag);
                }
                comp.position = tag_location_start;
                sections.back()->children.push_back(comp);

                // Start next search after this tag
                input_position = tag_location_end + current_tag_delimiter_end_size;

                // Push or pop sections
                if (comp.tag.is_section_begin()) {
                    sections.push_back(&sections.back()->children.back());
                    section_starts.push_back(input_position);
                } else if (comp.tag.is_section_end()) {
                    if (sections.size() == 1) {
                        streamstring ss;
                        ss << "Unopened section \"" << comp.tag.name << "\" at " << comp.position;
                        error_message_.assign(ss.str());
                        return;
                    }
                    sections.back()->tag.section_text.reset(new string_type(
                      input.substr(section_starts.back(), tag_location_start - section_starts.back())));
                    sections.pop_back();
                    section_starts.pop_back();
                }
            }

            process_current_text();

            // Check for sections without an ending tag
            root_component_.walk_children([this](component_type& comp) -> walk_control_type {
                if (!comp.tag.is_section_begin()) {
                    return component_type::walk_control::walk;
                }
                if (comp.children.empty() || !comp.children.back().tag.is_section_end() ||
                    comp.children.back().tag.name != comp.tag.name) {
                    streamstring ss;
                    ss << "Unclosed section \"" << comp.tag.name << "\" at " << comp.position;
                    error_message_.assign(ss.str());
                    return component_type::walk_control::stop;
                }
                comp.children.pop_back(); // remove now useless end section component
                return component_type::walk_control::walk;
            });
            if (!error_message_.empty()) {
                return;
            }
        }

        bool is_set_delimiter_valid(string_view_type delimiter) const {
            // "Custom delimiters may not contain whitespace or the equals sign."
            // todo: optimize-able
            for (const auto ch : delimiter) {
                if (ch == '=' || stl::isspace(ch)) {
                    return false;
                }
            }
            return true;
        }

        bool parse_set_delimiter_tag(string_view_type            contents,
                                     delimiter_set<string_type>& delimiter_set) const {
            // Smallest legal tag is "=X X="
            if (contents.size() < 5) {
                return false;
            }
            if (contents.back() != '=') {
                return false;
            }
            contents = contents.substr(1, contents.size() - 2); // todo: use remove_prefix and remove_suffix
            ascii::trim(contents);
            const auto spacepos = contents.find(' ');
            if (spacepos == string_view_type::npos) {
                return false;
            }
            const auto nonspace = contents.find_first_not_of(' ', spacepos + 1);
            assert(nonspace != string_type::npos);
            const auto begin = contents.substr(0, spacepos);
            const auto end   = contents.substr(nonspace, contents.size() - nonspace);
            if (!is_set_delimiter_valid(begin) || !is_set_delimiter_valid(end)) {
                return false;
            }
            delimiter_set.begin = begin;
            delimiter_set.end   = end;
            return true;
        }

        void parse_tag_contents(bool                    is_unescaped_var,
                                string_view_type        contents,
                                mstch_tag<string_type>& tag) const {
            if (is_unescaped_var) {
                tag.type = tag_type::unescaped_variable;
                tag.name = contents;
            } else if (contents.empty()) {
                tag.type = tag_type::variable;
                tag.name.clear();
            } else {
                switch (contents.at(0)) {
                    case '#': tag.type = tag_type::section_begin; break;
                    case '^': tag.type = tag_type::section_begin_inverted; break;
                    case '/': tag.type = tag_type::section_end; break;
                    case '>': tag.type = tag_type::partial; break;
                    case '&': tag.type = tag_type::unescaped_variable; break;
                    case '!': tag.type = tag_type::comment; break;
                    default: tag.type = tag_type::variable; break;
                }
                if (tag.type == tag_type::variable) {
                    tag.name = contents;
                } else {
                    string_type name{contents};
                    name.erase(name.begin());
                    ascii::trim(name);
                    tag.name = name;
                }
            }
        }



        ////// Renderer




        constexpr string_type render(context_internal<string_type>& ctx) {
            stl::basic_ostringstream<typename string_type::value_type> ss;
            render(
              [&ss](string_view_type str) {
                  ss << str;
              },
              ctx);
            return ss.str();
        }

        constexpr void
        render(const render_handler& handler, context_internal<string_type>& ctx, bool root_renderer = true) {
            root_component_.walk_children([&handler, &ctx, this](component_type& comp) -> walk_control_type {
                return render_component(handler, ctx, comp);
            });
            // process the last line, but only for the top-level renderer
            if (root_renderer) {
                render_current_line(handler, ctx, nullptr);
            }
        }

        constexpr void render_current_line(const render_handler&          handler,
                                           context_internal<string_type>& ctx,
                                           const component_type*          comp) const {
            // We're at the end of a line, so check the line buffer state to see
            // if the line had tags in it, and also if the line is now empty or
            // contains whitespace only. if this situation is true, skip the line.
            if (!ctx.line_buffer.contained_section_tag ||
                !ctx.line_buffer.is_empty_or_contains_only_whitespace()) {
                handler(ctx.line_buffer.data);
                if (comp) {
                    handler(comp->text);
                }
            }
            ctx.line_buffer.clear();
        }

        constexpr void render_result(context_internal<string_type>& ctx, string_view_type text) const {
            ctx.line_buffer.data.append(text);
        }

        constexpr walk_control_type render_component(const render_handler&          handler,
                                                     context_internal<string_type>& ctx,
                                                     component_type&                comp) {
            if (comp.is_text()) {
                if (comp.is_newline()) {
                    render_current_line(handler, ctx, &comp);
                } else {
                    render_result(ctx, comp.text);
                }
                return component_type::walk_control::walk;
            }

            const mstch_tag<string_type>&  tag{comp.tag};
            const basic_data<traits_type>* var = nullptr;
            switch (tag.type) {
                case tag_type::variable:
                case tag_type::unescaped_variable:
                    if ((var = ctx.ctx.get(tag.name)) != nullptr) {
                        if (!render_variable(handler, var, ctx, tag.type == tag_type::variable)) {
                            return component_type::walk_control::stop;
                        }
                    }
                    break;
                case tag_type::section_begin:
                    if ((var = ctx.ctx.get(tag.name)) != nullptr) {
                        if (var->is_lambda() || var->is_lambda2()) {
                            if (!render_lambda(handler,
                                               var,
                                               ctx,
                                               render_lambda_escape::optional,
                                               *comp.tag.section_text,
                                               true)) {
                                return component_type::walk_control::stop;
                            }
                        } else if (!var->is_false() && !var->is_empty_list()) {
                            render_section(handler, ctx, comp, var);
                        }
                    }
                    return component_type::walk_control::skip;
                case tag_type::section_begin_inverted:
                    if ((var = ctx.ctx.get(tag.name)) == nullptr || var->is_false() || var->is_empty_list()) {
                        render_section(handler, ctx, comp, var);
                    }
                    return component_type::walk_control::skip;
                case tag_type::partial:
                    if ((var = ctx.ctx.get_partial(tag.name)) != nullptr &&
                        (var->is_partial() || var->is_string())) {
                        const auto& partial_result =
                          var->is_partial() ? var->partial_value()() : var->string_value();
                        mustache tmpl{partial_result};
                        tmpl.set_custom_escape(escape_);
                        if (!tmpl.is_valid()) {
                            error_message_ = tmpl.error_message();
                        } else {
                            tmpl.render(handler, ctx, false);
                            if (!tmpl.is_valid()) {
                                error_message_ = tmpl.error_message();
                            }
                        }
                        if (!tmpl.is_valid()) {
                            return component_type::walk_control::stop;
                        }
                    }
                    break;
                case tag_type::set_delimiter: ctx.delim_set = *comp.tag.delim_set; break;
                default: break;
            }

            return component_type::walk_control::walk;
        }

        enum class render_lambda_escape {
            escape,
            unescape,
            optional,
        };

        constexpr bool render_lambda(const render_handler&          handler,
                                     const basic_data<traits_type>* var,
                                     context_internal<string_type>& ctx,
                                     render_lambda_escape           escape,
                                     string_view_type               text,
                                     bool                           parse_with_same_context) {
            const typename basic_renderer<string_type>::type2 render2 =
              [this, &ctx, parse_with_same_context, escape](string_view_type text, bool escaped) {
                  const auto process_template = [this, &ctx, escape, escaped](mustache& tmpl) -> string_type {
                      if (!tmpl.is_valid()) {
                          error_message_ = tmpl.error_message();
                          return {};
                      }
                      context_internal<string_type> render_ctx{ctx.ctx}; // start a new line_buffer
                      const auto                    str = tmpl.render(render_ctx);
                      if (!tmpl.is_valid()) {
                          error_message_ = tmpl.error_message();
                          return {};
                      }
                      bool do_escape = false;
                      switch (escape) {
                          case render_lambda_escape::escape: do_escape = true; break;
                          case render_lambda_escape::unescape: do_escape = false; break;
                          case render_lambda_escape::optional: do_escape = escaped; break;
                      }
                      return do_escape ? escape_(str) : str;
                  };
                  if (parse_with_same_context) {
                      mustache tmpl{text, ctx};
                      tmpl.set_custom_escape(escape_);
                      return process_template(tmpl);
                  }
                  mustache tmpl{text};
                  tmpl.set_custom_escape(escape_);
                  return process_template(tmpl);
              };
            const typename basic_renderer<string_type>::type1 render = [&render2](string_view_type text) {
                return render2(text, false);
            };
            if (var->is_lambda2()) {
                const basic_renderer<string_type> renderer{render, render2};
                render_result(ctx, var->lambda2_value()(text, renderer));
            } else {
                render_current_line(handler, ctx, nullptr);
                render_result(ctx, render(var->lambda_value()(text)));
            }
            return error_message_.empty();
        }

        constexpr bool render_variable(const render_handler&          handler,
                                       const basic_data<traits_type>* var,
                                       context_internal<string_type>& ctx,
                                       bool                           escaped) {
            if (var->is_string()) {
                const auto& varstr = var->string_value();
                render_result(ctx, escaped ? escape_(varstr) : varstr);
            } else if (var->is_lambda()) {
                const render_lambda_escape escape_opt =
                  escaped ? render_lambda_escape::escape : render_lambda_escape::unescape;
                return render_lambda(handler, var, ctx, escape_opt, {}, false);
            } else if (var->is_lambda2()) {
                using streamstring = stl::basic_ostringstream<typename string_type::value_type>;
                streamstring ss;
                ss << "Lambda with render argument is not allowed for regular variables";
                error_message_ = ss.str();
                return false;
            }
            return true;
        }

        constexpr void render_section(const render_handler&          handler,
                                      context_internal<string_type>& ctx,
                                      component_type&                incomp,
                                      const basic_data<traits_type>* var) {
            const auto callback = [&handler, &ctx, this](component_type& comp) -> walk_control_type {
                return render_component(handler, ctx, comp);
            };
            if (var && var->is_non_empty_list()) {
                for (const auto& item : var->list_value()) {
                    // account for the section begin tag
                    ctx.line_buffer.contained_section_tag = true;

                    const context_pusher<string_type> ctxpusher{ctx, &item};
                    incomp.walk_children(callback);

                    // ctx may have been cleared. account for the section end tag
                    ctx.line_buffer.contained_section_tag = true;
                }
            } else if (var) {
                // account for the section begin tag
                ctx.line_buffer.contained_section_tag = true;

                const context_pusher<string_type> ctxpusher{ctx, var};
                incomp.walk_children(callback);

                // ctx may have been cleared. account for the section end tag
                ctx.line_buffer.contained_section_tag = true;
            } else {
                // account for the section begin tag
                ctx.line_buffer.contained_section_tag = true;

                incomp.walk_children(callback);

                // ctx may have been cleared. account for the section end tag
                ctx.line_buffer.contained_section_tag = true;
            }
        }
    };

} // namespace webpp::views

#endif // WEBPP_MUSTACHE_HPP
